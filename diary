this is diary for project.
should not push to repository


実装する機能
・フロントエンド
ログイン
商品検索
商品一覧
商品詳細
お買い物かご
決済
通知
プロファイル
評価
お気に入り


・バックエンド（マイクロサービス：サービス単位で記載）
認証・認可サービス（DB:ユーザー,権限）
商品管理（DB:商品の管理）
決済（DB:なし、StripeAPIとの接続後、商品管理とメール、配送、お買い物かごにイベント通知）
通知（DB:通知保管、操作後にメールにイベント通知）
メール（主に決済のイベントから、もしくは通知から）
ログ（Mongo）
配送（？）
お買い物かご（DB：候補商品）
お気に入り（DB：お気に入り）


・実装未定（無理かも）
？？？
おすすめ
広告
割引表示


・開発環境
VSCodeもしくはその他IDE
任意のDB、ログについてはMongo予定。そのほかは標準的なRDB
各サービスはローカルでDockerComposeもしくはMinikubeで動かす
CICDパイプラインの実装によるテスト自動化（デプロイ先は予定していない）



5/31
認証サービスの環境構築
簡易的な認証サービすの設計
DBの設計⇨ユーザー管理のためのテーブルのみを設計

枠から作成
DBコネクションとルータとなるマルチプレクサ作成
上記の双方をサーバに登録、サーバ起動
CRUDはDBに移譲
各APIの呼び方だけを知っている状態を確率したい

6/2
認証APIのほぼ完成を目指す
ミドルウェアの設定でハマる、フレームワークないとなかなかむずい
ラップがしょーみわからん、Compositionというみたいだが
Middlewareという関数シグネチャを命名することでHttp.Handlerを受け取ってHttp.Hanlderを返す関数を定義できる
ループないでどんどんラップ指定って最後にMuxをもらってHttp.Handlerを返す関数を返せば
CreateMiddleware(xs ...Middleware) http.Handlerみたいなかんじにできる
DokcerFIleの書き方⇨From,MKDIR、WORKDIR⇨ワーキングディレクトリの設定、COPY、CMD

＊タスク
・ログイン実装
・JWTトークン作成機能
・JWTトークン認証機能
・リフレッシュトークン機能

6/3
サインアップとログイン機能整備
JWTの生成、検証は未実装
InitSQLの作成後DokcerCOmposeで起動確認と動作確認
明日はBrokerからKafkaにメッセージ飛ばしてやりとりできるか、もしくはGRPCでAuthできるか見ていく

6/4
サインアップと認証機能実装
DBコネクトの際はCOmposen場合はLocalhostではなくサービス名で指定
Dockerfileを作成するときにビルド対象のファイルすべてをいれるのではなく必要なCOnfigとかも持っていく
マルチステージビルドにできるとなおよし
HS256とES256で必要なKeyが違うみたい

次はBrokerを噛ませてAuthを呼び出すようにするAuthに対してはgRPCで行ってみたいわざわざKafka使うのも変かな

6/5
API_Gatewayを作成して認証できるか確認
名前解決できないのか
port指定したらポート指定しないとコネクションできないけど、ポート指定しないとかHTTP標準のポートを使用してPらポートをURLに含めなくてもよい
Githubにモジュール公開したらマイクロサービス間で共通処理をかける、
公開手順
・リポジトリ作成
・実装、go mod init のときにgithub.comから始まるリポジトリ名に合致したモジュール名にすること
・Mainパッケージで使用するORパッケージ名が衝突する可能性も考えてMainでなくてもよい
・Tagをつけるとバージョンを管理できる、タグの指定がなければ基本的には最新コミット
・ MODキャッシュが残っている可能性があるので注意

NEXT:ログサービスとMongo
NextJS学んでページ作るか
認証からKafkaにイベんと飛ばしてログサービスがログ登録

6/6
log-serviceの方はできたからあとはKafkaたてて認証からのPubとログがSubするのを作成する
Kafkaとzookeeperの関係性⇨Zookeeperが管理者で作業者がKafkaになる
実際のイベント送信はKafkaのポートに送るようにする
Kafka関連のProducerとConsumerでそれぞれこーどを設定する必要がある
KafkaのライブラリでIBM/saramaを使用、
とにかくPublishしてSubscribeしたイベントに対して内容を読み取って処理をするようにすればいい

6/8
Consumerの設定
認証kらイベントPublishしてログ登録まで
Bsonの記載方法 ***

6/9
認証からKafka通じてログ記載まで実装
エラー：Kafka起動前にログと認証サービスがコネクションできずにエラー落ちPanicで
解決法：バックオフの時間を設定しながらコネクションのリトライをサーバー側で設定
他にもDockerCompose側でヘルスチェックを実行して、それに依存する形でログと認証」サービスを」起動する方法もある
その場合はヘルスチェックの」内容をKafka側に記載したうえでdepends_onにヘルスチェックがどうなったらまで」を記載すること
次はgRPCでAPIGatewayから認証までを飛ばすようにする
それができたら、次は商品検索とかの実装とフロントエンドの実装をしていく
NextJsを学ぶか......ここでTypeScriptをしっておくと今後便利ではあるが.....

6/13
子供の熱によりしばらく間が空いた
メールサービすの実装
認証からログとメールのイベントを出してそれをSubしたメールサービスがメール送信
go net/smtpライブラリでできるみたい、SMTPやからきっとメール送信できるドメインのユーザーが必要やけど
Googleでできるはず、アカウントの設定さえすればできるはず
思ったより高速でできた
とりあえずサインアップと認証のどちらもイベント発行してメール送信は確認
次はメールのテンプレートをもう少し丁寧していく
注文完了メールも作成する


6/15
FrontEnd 学ぼう
NextJSとTypeScript

6/18
NextJs眠たくなる
残りのサービスは
・各サービスがJWTのトークン認証
・商品管理（DB:商品の管理）
・決済（DB:なし、StripeAPIとの接続後、商品管理とメール、配送、お買い物かごにイベント通知）
・通知（DB:通知保管、操作後にメールにイベント通知）⇨ フロントできてからがいい
・お買い物かご（DB：候補商品）
・お気に入り（DB：お気に入り）

ということで次は商品サービs流
管理するのは
商品マスタ：名前、単価、特徴、評価
タグ：中間テーブル
タグマスタ：カテゴリ管理

でもまずはメール内容をしっかりとしたい
HTMLメールと平文メールをmultipart/alternativeでおくったら適切な方を選択する
goでtemplateを取得してプレースホルダー当てはめるには？

6/23
template.Mustしたらテンプレートを返してExecuteしたら構造体とかマップとかの情報をマッピングしてくれる
もしも他のIoを要しといたらそっちに書き込むし、bytes.Bufferに用意しといたらそっちに書き込むから素でリクエストボディとかを扱うときはいい

6/24
メール実装一旦完了
メールの未達を防ぐにはContentTypeをBase64にするのが主流
SMTPの流れとしては接続＞TLS＞認証＞FROMとTO決定＞書き込み＞Closeって感じ
それに対してDKIM、SPF、DMARCを使うことでより安全にメールを見ることができる
DKIMは内容の安全性
SPFは場所のアンゼイン製
DMARCはポリシーの安全性
